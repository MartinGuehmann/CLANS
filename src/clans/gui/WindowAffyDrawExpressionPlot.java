package clans.gui;

import java.util.*;

import clans.model.microarray.MicroarrayDatapoint;
import clans.model.microarray.Replicates;

public class WindowAffyDrawExpressionPlot extends javax.swing.JFrame {
    
    /**
     * 
     */
    private static final long serialVersionUID = -2423870452098304715L;

    public WindowAffyDrawExpressionPlot(ProgramWindow map, WindowAffyMicroarrayData parent) {
        initComponents();
        this.map=map;
        this.parent=parent;
        this.datavec=parent.datavec;
        draw1.init(parent.datavec.size());
        repaint();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {//GEN-BEGIN:initComponents
        corrmethodbuttongroup = new javax.swing.ButtonGroup();
        graphpanel = new javax.swing.JPanel();
        drawpanel = new javax.swing.JPanel();
        drawpanel.add(draw1);
        optionspanel = new javax.swing.JPanel();
        pearsonradiobutton = new javax.swing.JRadioButton();
        spearmanradiobutton = new javax.swing.JRadioButton();
        kendallradiobutton = new javax.swing.JRadioButton();
        mincorrlabel = new javax.swing.JLabel();
        mincorrtextfield = new javax.swing.JTextField();
        corranticorrcheckbox = new javax.swing.JCheckBox();
        buttonpanel = new javax.swing.JPanel();
        showbutton = new javax.swing.JButton();
        closebutton = new javax.swing.JButton();

        setTitle("Draw Expression Plot");
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                exitForm(evt);
            }
        });

        graphpanel.setLayout(new java.awt.BorderLayout());

        drawpanel.setLayout(new javax.swing.BoxLayout(drawpanel, javax.swing.BoxLayout.X_AXIS));

        drawpanel.setPreferredSize(new java.awt.Dimension(400, 200));
        drawpanel.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                drawpanelMouseDragged(evt);
            }
        });
        drawpanel.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                drawpanelMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                drawpanelMouseReleased(evt);
            }
        });

        graphpanel.add(drawpanel, java.awt.BorderLayout.CENTER);

        optionspanel.setLayout(new java.awt.GridLayout(0, 3));

        pearsonradiobutton.setSelected(true);
        pearsonradiobutton.setText("Pearson");
        corrmethodbuttongroup.add(pearsonradiobutton);
        optionspanel.add(pearsonradiobutton);

        spearmanradiobutton.setText("Spearman");
        corrmethodbuttongroup.add(spearmanradiobutton);
        optionspanel.add(spearmanradiobutton);

        kendallradiobutton.setText("Kendall");
        corrmethodbuttongroup.add(kendallradiobutton);
        optionspanel.add(kendallradiobutton);

        mincorrlabel.setText("Min. correlation:");
        optionspanel.add(mincorrlabel);

        mincorrtextfield.setText("0.9");
        optionspanel.add(mincorrtextfield);

        corranticorrcheckbox.setText("Anticorr=Corr?");
        optionspanel.add(corranticorrcheckbox);

        graphpanel.add(optionspanel, java.awt.BorderLayout.SOUTH);

        getContentPane().add(graphpanel, java.awt.BorderLayout.CENTER);

        buttonpanel.setLayout(new java.awt.GridLayout(1, 0));

        showbutton.setText("Set correlated genes as selected");
        showbutton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                showbuttonActionPerformed(evt);
            }
        });

        buttonpanel.add(showbutton);

        closebutton.setText("Close");
        closebutton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                closebuttonActionPerformed(evt);
            }
        });

        buttonpanel.add(closebutton);

        getContentPane().add(buttonpanel, java.awt.BorderLayout.SOUTH);

        pack();
    }//GEN-END:initComponents
    
    private void drawpanelMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_drawpanelMouseDragged
        if(mousex>=0){
            mousey=(int)((((float)(drawpanel.getHeight()-evt.getY())-draw1.yoffset)/(float)(drawpanel.getHeight()-draw1.yoffset-draw1.yoffset))*draw1.maxres);
            if(mousey<0){
                mousey=0;
            }
            if(mousey>draw1.maxres){
                mousey=draw1.maxres;
            }
            repaint();
        }
    }//GEN-LAST:event_drawpanelMouseDragged
    
    private void drawpanelMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_drawpanelMouseReleased
        if(mousex>=0){
            draw1.values[mousex]=mousey;
            mousex=0;
            mousey=0;
            repaint();
        }
    }//GEN-LAST:event_drawpanelMouseReleased
    
    private void drawpanelMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_drawpanelMousePressed
        mousex=(int)((((float)(evt.getX()-draw1.xoffset+draw1.xfactor/2))/(float)(draw1.drawwidth))*draw1.conditions);
        mousey=(int)((((float)(draw1.drawheight-(evt.getY()-draw1.yoffset)))/(float)(draw1.drawheight))*draw1.maxres);
        if(mousey<0){//then only check if the corresponding usevals is checked or not
            if(draw1.usevals[mousex]){
                draw1.usevals[mousex]=false;
            }else{
                draw1.usevals[mousex]=true;
            }
            mousex=-1;
            mousey=-1;
        }
        if(mousey>draw1.maxres){
            mousey=draw1.maxres;
        }
        if(mousex>=draw1.conditions){
            mousex=draw1.conditions-1;
        }
        repaint();
    }//GEN-LAST:event_drawpanelMousePressed
    
    private void showbuttonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_showbuttonActionPerformed
        // look at the expression values for all genes in the clans map and select those
        // with correlation values >=mincorr to the current graph.
        int corrmethod=0;
        if(pearsonradiobutton.isSelected()){
            corrmethod=0;
        }else if(spearmanradiobutton.isSelected()){
            corrmethod=1;
        }else if(kendallradiobutton.isSelected()){
            corrmethod=2;
        }
        boolean corranticorr=false;
        if(corranticorrcheckbox.isSelected()){
            corranticorr=true;
        }
        float mincorr=0.9f;
        try{
            mincorr=Float.parseFloat(mincorrtextfield.getText());
        }catch (NumberFormatException ne){
            javax.swing.JOptionPane.showMessageDialog(this,"unable to parse float from '"+mincorrtextfield.getText()+"'");
            return;
        }
        //now I have all the options I need; next, get the values and see which genes correlate with the drawn plot
        float[] vals=new float[draw1.conditions];
        for(int i=0;i<draw1.conditions;i++){
            if(draw1.usevals[i]){
                vals[i]=draw1.values[i];
            }else{
                vals[i]=-1;
            }
        }//end for i
        //now see how each of the genes in the clans map compares to the currently drawn graph.
        getcorrelated(corrmethod,corranticorr,mincorr,vals);
        if(map.data.selectedSequencesIndices.length==0){
            javax.swing.JOptionPane.showMessageDialog(this,"No correlated expressions found!");
        }else{
            map.repaint();
        }
        repaint();
    }//GEN-LAST:event_showbuttonActionPerformed
    
    private void closebuttonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_closebuttonActionPerformed
        this.setVisible(false);
        this.dispose();
    }//GEN-LAST:event_closebuttonActionPerformed
    
    /** Exit the Application */
    private void exitForm(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_exitForm
        this.setVisible(false);
        this.dispose();
    }//GEN-LAST:event_exitForm
    
    /**
     * @param args the command line arguments
     */
    //public static void main(String args[]) {
    //    new affygetgraphcorrdialog().show();
    //}
    
    ProgramWindow map=null;
    WindowAffyMicroarrayData parent=null;
    drawpanel draw1=new drawpanel();
    Vector<Replicates> datavec=null;
    int mousex=0;
    int mousey=0;
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel buttonpanel;
    private javax.swing.JButton closebutton;
    private javax.swing.JCheckBox corranticorrcheckbox;
    private javax.swing.ButtonGroup corrmethodbuttongroup;
    private javax.swing.JPanel drawpanel;
    private javax.swing.JPanel graphpanel;
    private javax.swing.JRadioButton kendallradiobutton;
    private javax.swing.JLabel mincorrlabel;
    private javax.swing.JTextField mincorrtextfield;
    private javax.swing.JPanel optionspanel;
    private javax.swing.JRadioButton pearsonradiobutton;
    private javax.swing.JButton showbutton;
    private javax.swing.JRadioButton spearmanradiobutton;
    // End of variables declaration//GEN-END:variables
    
    void getcorrelated(int corrmethod,boolean corranticorr,float mincorr,float[] vals){
        //get the genes in clans that correlate >=mincorr with vals (vals[i]==-1 means don't take that one into account)
        float corrval;
        //first see how many conditions I want to look at and convert the vals into datapoints
        int count=0;
        int conditions=vals.length;
        for(int i=0;i<conditions;i++){
            if(vals[i]!=-1){
                count++;
            }
        }
        MicroarrayDatapoint[] drawvals=new MicroarrayDatapoint[count];
        MicroarrayDatapoint[] currvals=new MicroarrayDatapoint[count];
        count=0;
        for(int i=0;i<conditions;i++){
            if(vals[i]!=-1){
                drawvals[count]=new MicroarrayDatapoint();
                drawvals[count].value=vals[i];
                count++;
            }
        }//end for i
        MicroarrayDatapoint[] invals;
        //now take each of the genes in clans in turn and see which correlate with what I drew
        java.util.ArrayList<Integer> selected=new java.util.ArrayList<Integer>();
        for(int i=map.data.sequence_names.length;--i>=0;){
            if(parent.valhash.containsKey(map.data.sequence_names[i])){
                invals=(MicroarrayDatapoint[])(parent.valhash.get(map.data.sequence_names[i]));
                //now make sure I only compare the same conditions
                count=0;
                for(int j=0;j<conditions;j++){
                    if(vals[j]!=-1){
                        currvals[count]=invals[j];
                        count++;
                    }
                }//end for j
                corrval=getcorrval(corrmethod,drawvals,currvals);
                if(corranticorr && corrval<0){
                    corrval=-corrval;
                }
                if(corrval>=mincorr){
                    selected.add(new Integer(i));
                }
            }else{
                System.err.println("ERROR; '"+map.data.sequence_names[i]+"' is mot present in microarray data");
            }
        }//end for i
        //now I know which I want to select
        map.data.selectedSequencesIndices=new int[selected.size()];
        for(int i=selected.size();--i>=0;){
            map.data.selectedSequencesIndices[i]=selected.get(i).intValue();
        }//end for i
    }//end getcorrelated
    
    //--------------------------------------------------------------------------
    
    float getcorrval(int corrmethod,MicroarrayDatapoint[] vals, MicroarrayDatapoint[] currvals){
        //compare this set of datapoints to the vals array and see how well they correlate
        if(corrmethod==0){//pearson
            return pearson(vals,currvals);
        }else if(corrmethod==1){//spearman
            return spearman(vals,currvals);
        }else if(corrmethod==2){//kendall
            return kendall(vals,currvals);
        }else{
            System.err.println("unknown corrmethod '"+corrmethod+"'");
            return 0;
        }
    }//end getcorrval
    
    //--------------------------------------------------------------------------
    //--------------------------------------------------------------------------
    
    float pearson(MicroarrayDatapoint[] dat1,MicroarrayDatapoint[] dat2){
        //get the linear correlation (pearsons) of these two datasets
        double retval=0;
        int num1=dat1.length;
        if(dat2.length!=num1){
            System.err.println("unequals number of elements for correlation calculation; skipping");
            return 0;
        }
        double avg1=0,avg2=0,tmp1=0,tmp2=0,sq1=0,sq2=0,sum=0;
        double mindiff=1e-20;//needed to offset a div0 possibility
        for(int i=num1;--i>=0;){
            avg1+=dat1[i].value;
            avg2+=dat2[i].value;
        }//end for i
        avg1/=num1;
        avg2/=num1;
        for(int i=num1;--i>=0;){
            tmp1=(dat1[i].value-avg1);
            tmp2=(dat2[i].value-avg2);
            sq1+=tmp1*tmp1;
            sq2+=tmp2*tmp2;
            sum+=tmp1*tmp2;
        }//end for i
        retval=sum/(java.lang.Math.sqrt(sq1*sq2)+mindiff);
        return (float)retval;
    }//end pearson
    
    float spearman(MicroarrayDatapoint[] indat1,MicroarrayDatapoint[] indat2){
        //get the spearman rank correlation of these two datasets UNWEIGHTED
        //Rs=(SUM(xi-xavg)*(yi-yavg))/(sqrt(SUM((xi-xavg)**2))*sqrt(SUM(yi-yavg)**2));
        double retval=0;
        int num=indat1.length;
        if(indat2.length!=num){
            System.err.println("unequals number of elements for correlation calculation; skipping");
            return 0;
        }
        //convert the indat to x,y points
        point[] data=new point[num];
        for(int i=num;--i>=0;){
            data[i]=new point(indat1[i].value,indat2[i].value);
        }//end for i
        int[] sames=rank(data);//sames holds the number of identities in x and y
        //numerical recipe method WORKS!
        double d,fac,sf,sg,en3n;
        en3n=((double)num)*num*num-num;//convert to double else errors for large numbers
        sf=sames[0];
        sg=sames[1];
        d=0;
        for(int i=num;--i>=0;){
            d+=(data[i].x-data[i].y)*(data[i].x-data[i].y);
        }//end for i
        fac=(1-sf/en3n)*(1-sg/en3n);
        retval=(1-(6/en3n)*(d+((sf+sg)/12)))/java.lang.Math.sqrt(fac);
        return (float)retval;
    }//end spearman
    
    static int[] rank(point[] dat){
        //rank the input points first by x and then by y values
        //but keep them coupled!
        //newer version & checked!
        //use weights to assign ranks (unweighted: all weights=1)
        //countw sums up the effective sequence number I am using
        //return sum of all(f**3-f) (f=number of elements for each tie)
        int[] retarr=new int[2];
        retarr[0]=0;
        retarr[1]=0;
        int num=dat.length;
        float last,addval;
        double countw;
        int count;
        //do the y ranking
        java.util.Arrays.sort(dat,new comparatory());
        last=dat[num-1].y;//make sure this is NOT the same as the first value
        for(int i=0;i<num;i++){
            last=dat[i].y;
            count=0;
            countw=0;
            while((i+count+1<num)&&(dat[i+count+1].y==last)){
                countw+=dat[i+1].weight;
                count++;
            }
            addval=((float)count)/2;//-2 because I add one before and one after match
            for(int j=0;j<=count;j++){
                dat[i+j].y=i+addval;
            }//end for j
            if(count>0){
                countw+=dat[i].weight;
                i+=count;
                retarr[1]+=(countw*countw*countw-countw);
            }
        }//end for i
        //do the x-ranking
        java.util.Arrays.sort(dat,new comparatorx());
        last=dat[num-1].x;//make sure this is NOT the same as the first value
        for(int i=0;i<num;i++){
            last=dat[i].x;
            count=0;
            countw=0;
            while((i+count+1<num)&&(dat[i+count+1].x==last)){
                countw+=dat[i+1].weight;
                count++;
            }
            addval=((float)count)/2;//-2 because I add one before and one after match
            for(int j=0;j<=count;j++){
                dat[i+j].x=i+addval;
            }//end for j
            if(count>0){
                countw+=dat[i].weight;
                i+=count;
                retarr[0]+=(countw*countw*countw-countw);
            }
        }//end for i
        return retarr;
    }//end rank
    
    float kendall(MicroarrayDatapoint[] dat1,MicroarrayDatapoint[] dat2){
        //get the kendall-tau rank correlation of these two datasets
        int num=dat1.length;
        if(dat2.length!=num){
            System.err.println("unequals number of elements for correlation calculation; skipping");
            return 0;
        }
        double retval=0;
        int j,k;
        double is=0,n2=0,n1=0;
        double aa, a2, a1;
        double addnum=0;
        for(j=0;j<num-1;j++){
            for(k=j+1;k<num;k++){
                addnum=2;
                a1=dat1[j].value-dat1[k].value;
                a2=dat2[j].value-dat2[k].value;
                aa=a1*a2;
                if(aa!=0){
                    n1+=addnum;
                    n2+=addnum;
                    if(aa>0){
                        is+=addnum;
                    }else{
                        is-=addnum;
                    }
                }else{
                    if(a1!=0){
                        n1+=addnum;
                    }
                    if(a2!=0){
                        n2+=addnum;
                    }
                }
            }//end for k
        }//end for j
        retval=is/(java.lang.Math.sqrt((double)n1)*java.lang.Math.sqrt((double)n2));
        return (float)retval;
    }//end kendall
    
    //--------------------------------------------------------------------------
    //--------------------------------------------------------------------------
    
    static class comparatorx implements java.util.Comparator<point> {
        public int compare(point o1, point o2) {
            float x1 = o1.x;
            float x2 = o2.x;
            return (x1 < x2 ? -1 : (x1 == x2 ? 0 : 1));
        }// end compare
    }// end class comparator

    static class comparatory implements java.util.Comparator<point> {
        public int compare(point o1, point o2) {
            float x1 = o1.y;
            float x2 = o2.y;
            return (x1 < x2 ? -1 : (x1 == x2 ? 0 : 1));
        }// end compare
    }// end class comparator
    
    class point{
        
        public point(){}
        public point(float x, float y,float weight){
            this.x=x;
            this.y=y;
            this.weight=weight;
        }
        public point(float x, float y){
            this.x=x;
            this.y=y;
            this.weight=1;
        }
        
        float x=0;
        float y=0;
        float weight=1;
    }
        
    //--------------------------------------------------------------------------
    //--------------------------------------------------------------------------
    
    class drawpanel extends javax.swing.JPanel{
        
        /**
         * 
         */
        private static final long serialVersionUID = 4704631183140020399L;
        
        public void init(int con){
            this.conditions=con;
            this.values=new int[conditions];
            usevals=new boolean[conditions];
            for(int i=0;i<conditions;i++){
                usevals[i]=true;
            }
            repaint();
        }
        
        int conditions=0;
        int[] values=new int[0];
        boolean[] usevals=new boolean[0];
        int xoffset=20;
        int yoffset=20;
        float xfactor,yfactor;
        int maxres=100;
        int drawwidth=0;
        int drawheight=0;
        int rectsize=6;
        
        public void paintComponent(java.awt.Graphics g){
            super.paintComponent(g);
            if(conditions>0){
                drawwidth=drawpanel.getWidth()-(xoffset+xoffset);
                drawheight=drawpanel.getHeight()-(yoffset+yoffset);
                g.setColor(java.awt.Color.white);
                g.fillRect(0,0,drawpanel.getWidth(),drawpanel.getHeight());
                xfactor=(float)drawwidth/(float)conditions;
                yfactor=(float)drawheight/(float)maxres;
                //draw the axes
                g.setColor(java.awt.Color.black);
                g.drawLine(xoffset, yoffset, xoffset, yoffset+drawheight);
                g.drawLine(xoffset, drawheight+yoffset, xoffset+drawwidth, drawheight+yoffset);
                //draw vertical lines showing the conditions
                g.setColor(java.awt.Color.lightGray);
                Replicates myrep;
                for(int i=0;i<conditions;i++){
                    g.drawLine((int)(i*xfactor)+xoffset,yoffset,(int)(i*xfactor)+xoffset,yoffset+drawheight);
                    myrep=datavec.get(i);
                    if(myrep.abbreviation==null){
                        g.drawString(String.valueOf(i),(int)(i*xfactor)+xoffset,drawheight+yoffset);
                    }else{
                        g.drawString(myrep.abbreviation,(int)(i*xfactor)+xoffset,drawheight+yoffset);
                    }
                }//end for i
                //and now draw the data
                g.setColor(java.awt.Color.black);
                for(int i=1;i<conditions;i++){
                    g.drawLine((int)((i-1)*xfactor)+xoffset,(int)(drawheight-(values[i-1]*yfactor)+yoffset),(int)(i*xfactor)+xoffset,(int)(drawheight-(values[i]*yfactor)+yoffset));
                }//end for i
                //and now draw whether or not to use certain conditions
                g.drawString("Use:",0,drawheight+yoffset+yoffset);
                for(int i=0;i<conditions;i++){
                    if(usevals[i]){
                        g.fillRect((int)((i*xfactor)+xoffset-(rectsize/2)),drawheight+xoffset,rectsize,rectsize);
                    }else{
                        g.drawRect((int)((i*xfactor)+xoffset-(rectsize/2)),drawheight+xoffset,rectsize,rectsize);
                    }
                }//end for i
                //and now draw the current position for the mouse
                if(mousex>0 || mousey>0){//if the mouse is clicked
                    g.setColor(java.awt.Color.red);
                    if(mousex>0){
                        g.drawLine((int)((mousex-1)*xfactor)+xoffset,(int)(drawheight-(values[mousex-1]*yfactor)+yoffset),(int)(mousex*xfactor)+xoffset,(int)(drawheight-(mousey*yfactor)+yoffset));
                    }
                    if(mousex<conditions-1){
                        g.drawLine((int)((mousex+1)*xfactor)+xoffset,(int)(drawheight-(values[mousex+1]*yfactor)+yoffset),(int)(mousex*xfactor)+xoffset,(int)(drawheight-(mousey*yfactor)+yoffset));
                    }
                }
            }
        }//end paintcomponent
    }//end class drawpanel
    
}
