package clans.gui;

import javax.swing.*;
import javax.swing.tree.*;
// import javax.swing.event.TreeModelEvent;
import javax.swing.event.TreeModelListener;

import clans.model.microarray.MicroArrayFunctionMappingUtils;
import clans.model.microarray.MicroarrayMapnode;

import java.util.*;
import java.io.*;

public class WindowMicroarrayFunctionMapping extends javax.swing.JFrame {
    
    /**
     * 
     */
    private static final long serialVersionUID = -561248779145267780L;

    public WindowMicroarrayFunctionMapping(ClusteringWithGui parent) {
        this.parent=parent;
        initComponents();
        makenameshash();
        if(parent.mapfiles!=null){
            int selindex=-1;
            for(int i=0;i<parent.mapfiles.size();i++){
                //then load the mapping file
                if(((File)parent.mapfiles.get(i)).canRead()){
                    loadmapfile((File)parent.mapfiles.get(i));
                    if(parent.lookupfiles.get(i)!=null){
                        //then load the lookup files
                        if(((File)parent.lookupfiles.get(i)).canRead()){
                            loadlookupfile((File)parent.lookupfiles.get(i),i);
                        }else{
                            System.err.println("Warning: cannot read from '"+((File)parent.lookupfiles.get(i)).getAbsolutePath()+"'");
                        }
                    }
                    selindex++;
                }else{
                    System.err.println("Warning: cannot read from '"+((File)parent.mapfiles.get(i)).getAbsolutePath()+"'");
                }
            }
            tabpane.setSelectedIndex(selindex);
            if(selindex>-1){//if I successfully read a mapfile
                lookup = lookuplist.get(selindex);
                if(((Boolean)golist.get(selindex)).booleanValue()==false){
                    currtree=(javax.swing.JTree) treelist.get(selindex);
                }else{
                    //if I AM looking at GO-data, I want to also know what sub-tree I am looking at
                    ArrayList tmplist=(ArrayList)treelist.get(selindex);
                    int selindex2=0;
                    ((javax.swing.JTabbedPane)tabpane.getSelectedComponent()).setSelectedIndex(selindex2);
                    if(selindex2>-1){
                        currtree=(javax.swing.JTree) tmplist.get(selindex2);
                    }else{
                        javax.swing.JOptionPane.showMessageDialog(this,"No GO-tab selected!");
                    }
                }
                treeValueChanged();
            }
        }
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {//GEN-BEGIN:initComponents
        listpanel = new javax.swing.JPanel();
        jPanel1 = new javax.swing.JPanel();
        jSplitPane2 = new javax.swing.JSplitPane();
        tabpane = new javax.swing.JTabbedPane();
        jPanel2 = new javax.swing.JPanel();
        jPanel3 = new javax.swing.JPanel();
        showsubsettreebutton = new javax.swing.JButton();
        jTabbedPane1 = new javax.swing.JTabbedPane();
        jScrollPane1 = new javax.swing.JScrollPane();
        jPanel4 = new javax.swing.JPanel();
        infolist = new JList(infovector);
        jScrollPane2 = new javax.swing.JScrollPane();
        jPanel5 = new javax.swing.JPanel();
        infotextarea = new javax.swing.JTextArea();
        buttonpanel = new javax.swing.JPanel();
        mapbinsbutton = new javax.swing.JButton();
        mapclansbutton = new javax.swing.JButton();
        jMenuBar1 = new javax.swing.JMenuBar();
        filemenu = new javax.swing.JMenu();
        loadmenuitem = new javax.swing.JMenuItem();
        removemenuitem = new javax.swing.JMenuItem();
        loadlookupmenuitem = new javax.swing.JMenuItem();
        Edit = new javax.swing.JMenu();
        findmenitem = new javax.swing.JMenuItem();

        setTitle("Functional Mapping");
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                exitForm(evt);
            }
        });

        listpanel.setLayout(new javax.swing.BoxLayout(listpanel, javax.swing.BoxLayout.X_AXIS));

        listpanel.setPreferredSize(new java.awt.Dimension(500, 500));
        jPanel1.setLayout(new javax.swing.BoxLayout(jPanel1, javax.swing.BoxLayout.X_AXIS));

        jPanel1.setPreferredSize(new java.awt.Dimension(200, 500));
        jSplitPane2.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);
        tabpane.setPreferredSize(new java.awt.Dimension(400, 400));
        tabpane.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                tabpaneStateChanged(evt);
            }
        });

        jSplitPane2.setTopComponent(tabpane);

        jPanel2.setLayout(new java.awt.BorderLayout());

        jPanel3.setLayout(new java.awt.GridLayout(1, 0));

        showsubsettreebutton.setText("Focus on selected subset");
        showsubsettreebutton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                showsubsettreebuttonActionPerformed(evt);
            }
        });

        jPanel3.add(showsubsettreebutton);

        jPanel2.add(jPanel3, java.awt.BorderLayout.SOUTH);

        jPanel4.setLayout(new java.awt.BorderLayout());

        infolist.addListSelectionListener(new javax.swing.event.ListSelectionListener() {
            public void valueChanged(javax.swing.event.ListSelectionEvent evt) {
                infolistValueChanged(evt);
            }
        });

        jPanel4.add(infolist, java.awt.BorderLayout.CENTER);

        jScrollPane1.setViewportView(jPanel4);

        jTabbedPane1.addTab("List", jScrollPane1);

        jPanel5.setLayout(new javax.swing.BoxLayout(jPanel5, javax.swing.BoxLayout.X_AXIS));

        jPanel5.add(infotextarea);

        jScrollPane2.setViewportView(jPanel5);

        jTabbedPane1.addTab("Text", jScrollPane2);

        jPanel2.add(jTabbedPane1, java.awt.BorderLayout.CENTER);

        jSplitPane2.setRightComponent(jPanel2);

        jPanel1.add(jSplitPane2);

        listpanel.add(jPanel1);

        getContentPane().add(listpanel, java.awt.BorderLayout.CENTER);

        buttonpanel.setLayout(new java.awt.GridLayout(1, 0));

        mapbinsbutton.setText("Show bin(s) in clans");
        mapbinsbutton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mapbinsbuttonActionPerformed(evt);
            }
        });

        buttonpanel.add(mapbinsbutton);

        mapclansbutton.setText("Show clans in bin(s) (slow)");
        mapclansbutton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mapclansbuttonActionPerformed(evt);
            }
        });

        buttonpanel.add(mapclansbutton);

        getContentPane().add(buttonpanel, java.awt.BorderLayout.SOUTH);

        filemenu.setText("File");
        loadmenuitem.setText("Add mapping");
        loadmenuitem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                loadmenuitemActionPerformed(evt);
            }
        });

        filemenu.add(loadmenuitem);

        removemenuitem.setText("Remove mapping");
        removemenuitem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                removemenuitemActionPerformed(evt);
            }
        });

        filemenu.add(removemenuitem);

        loadlookupmenuitem.setText("Load lookup file");
        loadlookupmenuitem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                loadlookupmenuitemActionPerformed(evt);
            }
        });

        filemenu.add(loadlookupmenuitem);

        jMenuBar1.add(filemenu);

        Edit.setText("Menu");
        findmenitem.setText("Search for");
        findmenitem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                findmenitemActionPerformed(evt);
            }
        });

        Edit.add(findmenitem);

        jMenuBar1.add(Edit);

        setJMenuBar(jMenuBar1);

        pack();
    }//GEN-END:initComponents
    
    private void infolistValueChanged(javax.swing.event.ListSelectionEvent evt) {//GEN-FIRST:event_infolistValueChanged
        //make sure the current element is visible
        TreePath[] selectedpaths=currtree.getSelectionPaths();
        int selected=infolist.getSelectedIndex();
        if(selected>-1){
            currtree.scrollPathToVisible(selectedpaths[selected]);
        }
    }//GEN-LAST:event_infolistValueChanged
    
    private void showsubsettreebuttonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_showsubsettreebuttonActionPerformed
        //show only the subset of the selected tree paths that I selected in the info text dialog
        TreePath[] selectedpaths=currtree.getSelectionPaths();
        int[] selecteds=infolist.getSelectedIndices();
        int num;
        if((num=selecteds.length)>0){
            TreePath[] newpaths=new TreePath[num];
            for(int i=0;i<num;i++){
                newpaths[i]=selectedpaths[selecteds[i]];
            }//end for i
            collapsetree(currtree);
            currtree.setSelectionPaths(newpaths);
        }else{
            javax.swing.JOptionPane.showMessageDialog(this,"Nothing selected");
        }
    }//GEN-LAST:event_showsubsettreebuttonActionPerformed
    
    private void findmenitemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_findmenitemActionPerformed
        // search for a specific keyword in the bin "info"
        String querystring=javax.swing.JOptionPane.showInputDialog(this,"Enter query");
        if(querystring.length()>0){
            //then search through the tree and highlight the matching nodes
            searchtree(querystring);
        }
    }//GEN-LAST:event_findmenitemActionPerformed
    
    private void tabpaneStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_tabpaneStateChanged
        //I need to update the "lookup" hashMap as I use that in the tree-renderer
        int selindex=tabpane.getSelectedIndex();
        if(selindex>-1){
            lookup = lookuplist.get(selindex);
            if(((Boolean)golist.get(selindex)).booleanValue()==false){
                currtree=(javax.swing.JTree) treelist.get(selindex);
            }else{
                //if I AM looking at GO-data, I want to also know what sub-tree I am looking at
                ArrayList tmplist=(ArrayList)treelist.get(selindex);
                int selindex2=((javax.swing.JTabbedPane)tabpane.getSelectedComponent()).getSelectedIndex();
                if(selindex2>-1){
                    currtree=(javax.swing.JTree) tmplist.get(selindex2);
                }else{
                    javax.swing.JOptionPane.showMessageDialog(this,"No GO-tab selected!");
                }
            }
            treeValueChanged();
        }
    }//GEN-LAST:event_tabpaneStateChanged
    
    private void removemenuitemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_removemenuitemActionPerformed
        // remove the currently selected element from the tab
        int selindex=tabpane.getSelectedIndex();
        if(selindex>-1){
            tabpane.remove(selindex);
            maplist.remove(selindex);
            lookuplist.remove(selindex);
            golist.remove(selindex);
            treelist.remove(selindex);
            parent.mapfiles.remove(selindex);
            parent.lookupfiles.remove(selindex);
            repaint();
        }else{
            javax.swing.JOptionPane.showMessageDialog(this,"No tab selected!");
        }
    }//GEN-LAST:event_removemenuitemActionPerformed
    
    private void mapclansbuttonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mapclansbuttonActionPerformed
        // get the selected sequences from clans and show which functional categories they belong to by selecting them and collapsing the rest
        //see if any sequences are selected in the parent
        int selectednum=parent.data.selectedSequencesIndices.length;
        if(selectednum>0){
            //find all the tree leaf-nodes corresponding to the selected names
            //set these as selected in the tree (expand branches as necessary)
            String[] selectednames=new String[selectednum];
            for(int i=selectednum;--i>=0;){
                selectednames[i]=parent.data.sequence_names[parent.data.selectedSequencesIndices[i]].toLowerCase();
            }//end for i
            settreeselected(selectednames);
        }else{
            javax.swing.JOptionPane.showMessageDialog(this,"You need to select some sequences in CLANS");
        }
    }//GEN-LAST:event_mapclansbuttonActionPerformed
    
    private void loadlookupmenuitemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_loadlookupmenuitemActionPerformed
        // load a lookup file mapping the affy names to whatever description is in the classification file
        int selindex=tabpane.getSelectedIndex();
        if(selindex>-1){
            fc.setMultiSelectionEnabled(false);
            fc.setDialogTitle("Select file to load lookup data from (AFTER loading the mapping!)");
            fc.setApproveButtonText("Load Lookup");
            int returnVal = fc.showOpenDialog(this);
            if(returnVal == JFileChooser.APPROVE_OPTION) {
                File savefile=fc.getSelectedFile();
                parent.lookupfiles.set(selindex,savefile);
                if(loadlookupfile(savefile,selindex)==false){
                    parent.lookupfiles.set(selindex,null);
                }
            }
            repaint();
        }else{
            javax.swing.JOptionPane.showMessageDialog(this,"You need to load a mapping before loading a lookup");
        }
    }//GEN-LAST:event_loadlookupmenuitemActionPerformed
    
    private void mapbinsbuttonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mapbinsbuttonActionPerformed
        //select all the specified sequences in the graph
        int selindex=tabpane.getSelectedIndex();
        if(selindex>-1){
            //get the scrollpanel
            javax.swing.JTree tree;
            if(((Boolean)golist.get(selindex)).booleanValue()==false){
                tree=(javax.swing.JTree) treelist.get(selindex);
            }else{
                //if I AM looking at GO-data, I want to also know what sub-tree I am looking at
                ArrayList tmplist=(ArrayList)treelist.get(selindex);
                int selindex2=((javax.swing.JTabbedPane)tabpane.getSelectedComponent()).getSelectedIndex();
                if(selindex2>-1){
                    tree=(javax.swing.JTree) tmplist.get(selindex2);
                }else{
                    return;
                }
            }
            
            HashMap<String, String> mylookup = lookuplist.get(selindex);
            TreePath[] tmp=tree.getSelectionPaths();
            if(tmp==null){
                parent.data.selectedSequencesIndices=new int[0];
                parent.repaint();
                return;
            }
            
            HashMap<String, String> selectedhash=new HashMap<String, String>();
            MicroarrayMapnode currnode;
            for(int i=tmp.length;--i>=0;){
                currnode=(MicroarrayMapnode)tmp[i].getLastPathComponent();
                getleaves(currnode,selectedhash);
            }//end for i
            String[] selectednames=(String[]) selectedhash.values().toArray(new String[0]);
            selectedhash.clear();
            //now make sure I only have each leaf present ONCE
            //adding it to the hash will remove duplicate names
            for(int i=selectednames.length;--i>=0;){
                selectedhash.put(selectednames[i],null);
            }//end for i
            selectednames=(String[]) selectedhash.keySet().toArray(new String[0]);
            selectedhash.clear();
            
            //now I know which leaves I want to select
            //now I need to see which are present in the clans map
            ArrayList<Integer> selist = new ArrayList<Integer>();
            for(int i=selectednames.length;--i>=0;){
                if(nameshash.containsKey(selectednames[i])){
                    //System.out.println("nameshash contains "+selectednames[i]);
                    selist.add(parent.data.nameshash.get(nameshash.get(selectednames[i])));
                }else{
                    //look in the lookup file
                    if(mylookup!=null){
                        if(mylookup.containsKey(selectednames[i])){
                            //System.out.println("found '"+selectednames[i]+"' in lookup -->'"+lookup.get(selectednames[i])+"'");
                            if((nameshash.containsKey(mylookup.get(selectednames[i])))){
                                Integer tmpi=(Integer)parent.data.nameshash.get(nameshash.get(mylookup.get(selectednames[i])));
                                if(tmpi!=null){
                                    selist.add(parent.data.nameshash.get(nameshash.get(mylookup.get(selectednames[i]))));
                                }else{
                                    System.out.println("ERROR is NULL for "+selectednames[i]+"->"+mylookup.get(selectednames[i])+"->"+nameshash.get(mylookup.get(selectednames[i]))+
                                    "->"+parent.data.nameshash.get(nameshash.get(mylookup.get(selectednames[i]))));
                                }
                            }
                        }
                    }
                }
            }//end for i
            //and now convert selist to an array of integer and assign that as parent.selectednames
            int selnum=selist.size();
            if(selnum==0){
                javax.swing.JOptionPane.showMessageDialog(this,"NO elements of this group found in clans file");
            }
            parent.data.selectedSequencesIndices=new int[selnum];
            for(int i=selnum;--i>=0;){
                parent.data.selectedSequencesIndices[i]=((Integer)selist.get(i)).intValue();
            }//end for i
            parent.repaint();
        }else{
            javax.swing.JOptionPane.showMessageDialog(this,"No Data/Tab selected");
        }
    }//GEN-LAST:event_mapbinsbuttonActionPerformed
    
    private void loadmenuitemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_loadmenuitemActionPerformed
        // load mapping data from a file
        fc.setMultiSelectionEnabled(false);
        fc.setDialogTitle("Select file to load from");
        fc.setApproveButtonText("Load Mapping");
        int returnVal = fc.showOpenDialog(this);
        if(returnVal == JFileChooser.APPROVE_OPTION) {
            File savefile=fc.getSelectedFile();
            if(loadmapfile(savefile)){
                parent.mapfiles.add(savefile);
                parent.lookupfiles.add(null);
            }
        }
        repaint();
    }//GEN-LAST:event_loadmenuitemActionPerformed
    
    /** Exit the Application */
    private void exitForm(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_exitForm
        this.setVisible(false);
        this.dispose();
    }//GEN-LAST:event_exitForm
    
    /**
     * @param args the command line arguments
     */
    
    ClusteringWithGui parent=null;
    JFileChooser fc=new JFileChooser(new File("."));

    ArrayList<MicroarrayMapnode> maplist=new ArrayList<MicroarrayMapnode>();
    ArrayList<Boolean> golist=new ArrayList<Boolean>();
    ArrayList treelist=new ArrayList();
    javax.swing.JTree currtree=null;
    String linesep=System.getProperty("line.separator");
    HashMap<String, String> lookup=null;
    ArrayList<HashMap<String, String>> lookuplist=new ArrayList<HashMap<String, String>>();
    HashMap<String, String> nameshash=new HashMap<String, String>();
    String lookupfile="";
    Vector<String> infovector=new Vector<String>();

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenu Edit;
    private javax.swing.JPanel buttonpanel;
    private javax.swing.JMenu filemenu;
    private javax.swing.JMenuItem findmenitem;
    private javax.swing.JList infolist;
    private javax.swing.JTextArea infotextarea;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JSplitPane jSplitPane2;
    private javax.swing.JTabbedPane jTabbedPane1;
    private javax.swing.JPanel listpanel;
    private javax.swing.JMenuItem loadlookupmenuitem;
    private javax.swing.JMenuItem loadmenuitem;
    private javax.swing.JButton mapbinsbutton;
    private javax.swing.JButton mapclansbutton;
    private javax.swing.JMenuItem removemenuitem;
    private javax.swing.JButton showsubsettreebutton;
    private javax.swing.JTabbedPane tabpane;
    // End of variables declaration//GEN-END:variables
    
    boolean loadmapfile(File mapfile){
        MicroarrayMapnode map=null;
        if((map=MicroArrayFunctionMappingUtils.loadunknownformat(mapfile))==null){
            javax.swing.JOptionPane.showMessageDialog(this,"ERROR loading data from '"+mapfile.getName()+"'");
            return false;
        }else{//remember the successfully loaded file
            //parent.mapfile=mapfile;
            maplist.add(map);
            lookuplist.add(null);
            if(map.level=="GO-root"){
                //if I loaded GO-annotation, I want to output the most basal levels in separate tabs
                golist.add(new Boolean("true"));
                //now create a new tabbed panel and add the relevant tree
                javax.swing.JTabbedPane mytabpane=new javax.swing.JTabbedPane();
                mytabpane.addChangeListener(new javax.swing.event.ChangeListener() {
                    public void stateChanged(javax.swing.event.ChangeEvent evt) {
                        tabpaneStateChanged(evt);
                    }
                });
                ArrayList<JTree> tmptreelist=new ArrayList<JTree>();
                for(int i=0; i<map.child.length;i++){
                    javax.swing.JTree tree=new javax.swing.JTree(new mapmodel(map.child[i]));
                    tree.setCellRenderer(new maprenderer());
                    tree.addTreeSelectionListener(new javax.swing.event.TreeSelectionListener() {
                        public void valueChanged(javax.swing.event.TreeSelectionEvent evt) {
                            treeValueChanged();
                        }
                    });
                    tmptreelist.add(tree);
                    javax.swing.JScrollPane treescroll=new javax.swing.JScrollPane();
                    treescroll.setViewportView(tree);
                    mytabpane.addTab(map.child[i].info, treescroll);
                }//end for i
                treelist.add(tmptreelist);
                tabpane.addTab("M:"+mapfile.getName(), mytabpane);
            }else{
                golist.add(new Boolean("false"));
                javax.swing.JTree tree=new javax.swing.JTree(new mapmodel(map));
                tree.setCellRenderer(new maprenderer());
                tree.addTreeSelectionListener(new javax.swing.event.TreeSelectionListener() {
                    public void valueChanged(javax.swing.event.TreeSelectionEvent evt) {
                        treeValueChanged();
                    }
                });
                treelist.add(tree);
                javax.swing.JScrollPane treescroll=new javax.swing.JScrollPane();
                treescroll.setViewportView(tree);
                tabpane.addTab("M:"+mapfile.getName(), treescroll);
            }
        }
        return true;
    }//end loadmapfile
    
    //--------------------------------------------------------------------------
    
    private void treeValueChanged() {
        StringBuffer tmpbuff=new StringBuffer();
        infovector.clear();
        String addstring;
        if(currtree!=null){
            TreePath[] tmp=currtree.getSelectionPaths();
            if(tmp!=null){
                HashMap<String, String> tmphash = new HashMap<String, String>();// make sure no identical names are
                                                                                // added to either the list or the text
                if(lookup!=null){
                    int num=tmp.length;
                    for(int i=0;i<num;i++){
                        addstring=((MicroarrayMapnode)tmp[i].getLastPathComponent()).level+"->"+lookup.get(((MicroarrayMapnode)tmp[i].getLastPathComponent()).leaf)+":"+((MicroarrayMapnode)tmp[i].getLastPathComponent()).info;
                        if(lookup.containsKey(((MicroarrayMapnode)tmp[i].getLastPathComponent()).leaf)){
                            if(tmphash.containsKey(addstring)==false){
                                tmpbuff.append(addstring+linesep);
                                infovector.add(addstring);
                                tmphash.put(addstring,null);
                            }
                        }else{
                            addstring=((MicroarrayMapnode)tmp[i].getLastPathComponent()).level+":"+((MicroarrayMapnode)tmp[i].getLastPathComponent()).info;
                            if(tmphash.containsKey(addstring)==false){
                                tmpbuff.append(addstring+linesep);
                                infovector.add(addstring);
                                tmphash.put(addstring,null);
                            }
                        }
                    }
                }else{
                    int num=tmp.length;
                    for(int i=0;i<num;i++){
                        addstring=((MicroarrayMapnode)tmp[i].getLastPathComponent()).level+":"+((MicroarrayMapnode)tmp[i].getLastPathComponent()).info;
                        if(tmphash.containsKey(addstring)==false){
                            tmpbuff.append(addstring+linesep);
                            infovector.add(addstring);
                            tmphash.put(addstring,null);
                        }
                    }
                }
                infotextarea.setText(tmpbuff.toString());
            }else{
                infovector.add("Nothing selected");
                infotextarea.setText("Nothing selected");
            }
        }else{
            infovector.add("NoMapping loaded/selected");
            infotextarea.setText("No Mapping loaded/selected");
        }
        infolist.setListData(infovector);
        repaint();
    }//end treevaluechanged
    
    //--------------------------------------------------------------------------
    
    boolean loadlookupfile(File lookupfile, int index){
        HashMap<String, String> mylookup=null;
        if(((Boolean)golist.get(index)).booleanValue()==false){
            if((mylookup=MicroArrayFunctionMappingUtils.loadlookup(lookupfile))==null){
                javax.swing.JOptionPane.showMessageDialog(this,"ERROR loading lookup data from '"+lookupfile.getName()+"'");
                return false;
            }else{
                System.out.println("loading lookup to index"+index);
                lookuplist.set(index,mylookup);
                lookup=mylookup;
                tabpane.setTitleAt(index,"M:"+((File)parent.mapfiles.get(index)).getName()+" L:"+((File)parent.lookupfiles.get(index)).getName());
                return true;
            }
        }else{
            //in this case I am adding nodes to the tree and have to use a different method
            MicroArrayFunctionMappingUtils.loadGOlookup(lookupfile,(MicroarrayMapnode)maplist.get(index));
            lookup=null;
            tabpane.setTitleAt(index,"M:"+((File)parent.mapfiles.get(index)).getName()+" L:"+((File)parent.lookupfiles.get(index)).getName());
        }
        return true;
    }//end loadlookupfile
    
    //--------------------------------------------------------------------------
    
    void searchtree(String querystring){
        //used search for a specific keyword(s) in the bin descriptions (i.e. flavonoid or jasmonate synthesis)
        //and then set these as selected in the tree.
        int selindex=tabpane.getSelectedIndex();
        java.util.regex.Pattern query=java.util.regex.Pattern.compile("(?i).*"+querystring+".*");
        if(selindex>-1){
            //next, iterate through the tree-nodes and select those with matching names in the names hash
            ArrayList<TreePath> nodeslist=new ArrayList<TreePath>();
            ArrayList<MicroarrayMapnode> pathlist=new ArrayList<MicroarrayMapnode>();
            //now I have all the necessary tree-paths
            javax.swing.JTree tree;
            if(((Boolean)golist.get(selindex)).booleanValue()==false){
                tree=(javax.swing.JTree) treelist.get(selindex);
                pathlist.add((MicroarrayMapnode)maplist.get(selindex));
                gettreepaths(pathlist,nodeslist,query,false);
            }else{
                //if I AM looking at GO-data, I want to also know what sub-tree I am looking at
                ArrayList tmplist=(ArrayList)treelist.get(selindex);
                int selindex2=((javax.swing.JTabbedPane)tabpane.getSelectedComponent()).getSelectedIndex();
                if(selindex2>-1){
                    tree=(javax.swing.JTree) tmplist.get(selindex2);
                    pathlist.add(((MicroarrayMapnode)maplist.get(selindex)).child[selindex2]);
                    gettreepaths(pathlist,nodeslist,query,true);
                }else{
                    return;
                }
            }
            if(nodeslist.size()==0){
                javax.swing.JOptionPane.showMessageDialog(this,"No sequences found matching (?i).*"+querystring+".*");
            }else{
                collapsetree(tree);
                tree.setSelectionPaths(((javax.swing.tree.TreePath[])nodeslist.toArray(new javax.swing.tree.TreePath[0])));
                repaint();
            }
        }else{
            javax.swing.JOptionPane.showMessageDialog(this,"No Data/Tab selected");
        }
    }//end settreeselected
    
    /**
     * search through the tree and see which mapnodes correspond in name to one of the genes I'm looking for
     * 
     * @param pathlist
     * @param retlist
     * @param query
     * @param goterms
     */
    void gettreepaths(ArrayList<MicroarrayMapnode> pathlist, ArrayList<TreePath> retlist, java.util.regex.Pattern query,
            boolean goterms) {

        MicroarrayMapnode innode=(MicroarrayMapnode)pathlist.get(pathlist.size()-1);
        //System.out.println(innode.level);
        if(innode.child!=null){
            for(int i=innode.child.length;--i>=0;){
                ArrayList<MicroarrayMapnode> newpathlist=new ArrayList<MicroarrayMapnode>(pathlist);
                newpathlist.add(innode.child[i]);
                gettreepaths(newpathlist,retlist,query,goterms);
            }//end for i
            java.util.regex.Matcher m = query.matcher(innode.info);
            if(m.matches()){
                retlist.add(new javax.swing.tree.TreePath(((MicroarrayMapnode[])pathlist.toArray(new MicroarrayMapnode[0]))));
            }
        }else if(goterms==false){
            String checkstr=innode.info+" "+innode.leaf;
            if((lookup!=null) && (lookup.containsKey(innode.leaf))){
                checkstr+=" "+lookup.get(innode.leaf);
            }
            java.util.regex.Matcher m = query.matcher(checkstr);
            //System.out.println("checking '"+checkstr+"'");
            if(m.matches()){
                retlist.add(new javax.swing.tree.TreePath(((MicroarrayMapnode[])pathlist.toArray(new MicroarrayMapnode[0]))));
            }
        }
    }//end getleafnodes
    
    
    //--------------------------------------------------------------------------
    
    void settreeselected(String[] selectednames){
        //used for the map clans to bins
        //take the names present in selectednames, try to find the corresponding tree-tipnodes
        //and then set these as selected in the tree.
        int selindex=tabpane.getSelectedIndex();
        if(selindex>-1){
            HashMap<String, String> names=new HashMap<String, String>();
            int num=selectednames.length;
            if(lookup!=null){
                //System.out.println("lookup!=null");
                for(int i=num;--i>=0;){
                    if(lookup.containsKey(selectednames[i])){
                        names.put(lookup.get(selectednames[i]),selectednames[i]);
                    }
                    names.put(selectednames[i],null);
                }//end for i
            }else{//if I am not using a lookup hashmap to translate the affy numbers to the bin-gene names
                //System.out.println("lookup==null");
                for(int i=num;--i>=0;){
                    names.put(selectednames[i],null);
                }//end for i
            }
            //now I should have a feasible lookup for the names I want to look for
            //next, iterate through the tree-leafnodes and select those with matching names in the names hash
            ArrayList<TreePath> nodeslist=new ArrayList<TreePath>();
            ArrayList<MicroarrayMapnode> pathlist=new ArrayList<MicroarrayMapnode>();
            //now I have all the necessary tree-paths
            javax.swing.JTree tree;
            if(((Boolean)golist.get(selindex)).booleanValue()==false){
                tree=(javax.swing.JTree) treelist.get(selindex);
                pathlist.add((MicroarrayMapnode)maplist.get(selindex));
                gettreepaths(pathlist,nodeslist,names);
            }else{
                //if I AM looking at GO-data, I want to also know what sub-tree I am looking at
                ArrayList tmplist=(ArrayList)treelist.get(selindex);
                int selindex2=((javax.swing.JTabbedPane)tabpane.getSelectedComponent()).getSelectedIndex();
                if(selindex2>-1){
                    tree=(javax.swing.JTree) tmplist.get(selindex2);
                    pathlist.add(((MicroarrayMapnode)maplist.get(selindex)).child[selindex2]);
                    gettreepaths(pathlist,nodeslist,names);
                }else{
                    return;
                }
            }
            if(nodeslist.size()==0){
                javax.swing.JOptionPane.showMessageDialog(this,"None of the selected sequences has mapping information associated");
            }else{
                collapsetree(tree);
                tree.setSelectionPaths(((javax.swing.tree.TreePath[])nodeslist.toArray(new javax.swing.tree.TreePath[0])));
                repaint();
            }
        }else{
            javax.swing.JOptionPane.showMessageDialog(this,"No Data/Tab selected");
        }
    }//end settreeselected\
    
    void gettreepaths(ArrayList<MicroarrayMapnode> pathlist, ArrayList<TreePath> retlist, HashMap<String, String> names){
        //search through the tree and see which mapnodes correspond in name to one of the genes I'm looking for
        MicroarrayMapnode innode=(MicroarrayMapnode)pathlist.get(pathlist.size()-1);
        //System.out.println(innode.level);
        if(innode.child!=null){
            for(int i=innode.child.length;--i>=0;){
                ArrayList<MicroarrayMapnode> newpathlist=new ArrayList<MicroarrayMapnode>(pathlist);
                newpathlist.add(innode.child[i]);
                gettreepaths(newpathlist,retlist,names);
            }//end for i
        }else{
            String currname=innode.leaf;
            if(names.containsKey(currname)){
                retlist.add(new javax.swing.tree.TreePath(((MicroarrayMapnode[])pathlist.toArray(new MicroarrayMapnode[0]))));
            }//else{
            //System.out.println("Name '"+currname+"' not present in clans");
            //}
        }
    }//end getleafnodes
    
    //--------------------------------------------------------------------------
    
    void collapsetree(javax.swing.JTree tree){
        //collapse all expanded nodes in the tree
        for (int i = tree.getRowCount(); --i>0;) {//>0 so that the root is NOT collapsed
            tree.collapseRow(i);
        }
        repaint();
    }//end collapsetree
    
    //--------------------------------------------------------------------------
    
    void makenameshash(){
        //convert the names in parent.namearr into sth. with faster lookup
        //if I then map back the nameshash object via parent.namshash I should get an Integer object
        nameshash=new HashMap<String, String>();
        int num=parent.data.sequence_names.length;
        String key;
        for(int i=num;--i>=0;){
            key=parent.data.sequence_names[i];
            if(nameshash.containsKey(key)){
                System.err.println("Warning: '"+key+"' already defined by "+nameshash.get(key));
            }else{
                //now figure out what the corresponding name should be
                nameshash.put(key,parent.data.sequences[i].name);
            }
        }//end for i
    }//end makenameshash
    
    //--------------------------------------------------------------------------
    
    void getleaves(MicroarrayMapnode innode,HashMap<String, String> inhash){
        //get all the leaf-node-names
        if(innode.child!=null){
            for(int i=innode.child.length;--i>=0;){
                getleaves(innode.child[i],inhash);
            }
        }
        if(innode.leaf!=null){
            if(inhash.containsKey(innode.level)==false){
                inhash.put(innode.level,innode.leaf);
            }
        }
    }//end getleaves
    
    //--------------------------------------------------------------------------
    //--------------------------------------------------------------------------
    
    class maprenderer extends DefaultTreeCellRenderer {
        
        /**
         * 
         */
        private static final long serialVersionUID = -7765644828040844519L;

        public maprenderer() {
        }
        
        public java.awt.Component getTreeCellRendererComponent(
        JTree tree,
        Object value,
        boolean sel,
        boolean expanded,
        boolean leaf,
        int row,
        boolean hasFocus) {
            super.getTreeCellRendererComponent(
            tree, value, sel,
            expanded, leaf, row,
            hasFocus);
            MicroarrayMapnode node=((MicroarrayMapnode)value);
            if((lookup!=null) && (lookup.containsKey(node.leaf))){
                setText(node.level+" -->("+lookup.get(node.leaf)+")");
            }else{
                setText(node.level);
            }
            setToolTipText(node.info);
            return this;
        }
    }//end class maprenderer
    
    //--------------------------------------------------------------------------
    //--------------------------------------------------------------------------
    public class mapmodel implements TreeModel {
        private Vector<TreeModelListener> treeModelListeners = new Vector<TreeModelListener>();
        private MicroarrayMapnode rootnode=null;
        
        public mapmodel(MicroarrayMapnode root) {
            this.rootnode = root;
        }
        
        public void addTreeModelListener(TreeModelListener l) {
            treeModelListeners.addElement(l);
        }
        
        public Object getChild(Object parent, int index) {
            return ((MicroarrayMapnode)parent).child[index];
        }
        
        public int getChildCount(Object parent) {
            if(((MicroarrayMapnode)parent).child!=null){
                return ((MicroarrayMapnode)parent).child.length;
            }else{
                return 0;
            }
        }
        
        public int getIndexOfChild(Object parent, Object child) {
            return ((MicroarrayMapnode)parent).haschild((MicroarrayMapnode)child);
        }
        
        public Object getRoot() {
            return rootnode;
        }
        
        public boolean isLeaf(Object node) {
            if(((MicroarrayMapnode)node).child!=null){
                return false;
            }else{
                return true;
            }
        }
        
        public void removeTreeModelListener(TreeModelListener l) {
            treeModelListeners.removeElement(l);
        }
        
        /**
         * Messaged when the user has altered the value for the item
         * identified by path to newValue.  Not used by this model.
         */
        public void valueForPathChanged(TreePath path, Object newValue) {
            System.out.println("*** valueForPathChanged : "
            + path + " --> " + newValue);
        }
    }//end class treemodel
    
}
