package clans;

import java.awt.event.MouseEvent;
import java.util.*;

public class affyplotdialog extends javax.swing.JFrame {
    
    /**
     * 
     */
    private static final long serialVersionUID = 3098881348245117983L;

    public affyplotdialog(ArrayList<datapoint[]> inlist,float infloat,Vector<replicates> datavec) {
        this.datlist=inlist;
        this.datavec=datavec;
        draw1.globalrelstdev=infloat;
        draw1.init();
        initComponents();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {//GEN-BEGIN:initComponents
        graphpanel = new javax.swing.JPanel();
        graphpanel.add(draw1);
        xscrollbar = new javax.swing.JScrollBar();
        yscrollbar = new javax.swing.JScrollBar();
        jMenuBar1 = new javax.swing.JMenuBar();
        optionsmenu = new javax.swing.JMenu();
        relexpcheckbox = new javax.swing.JCheckBoxMenuItem();
        foldchangecheckbox = new javax.swing.JCheckBoxMenuItem();
        avgfoldchangecheckbox = new javax.swing.JCheckBoxMenuItem();
        shownamescheckbox = new javax.swing.JCheckBoxMenuItem();
        windowmenu = new javax.swing.JMenu();
        deselectmenuitem = new javax.swing.JMenuItem();
        showselectedwindowmenuitem = new javax.swing.JMenuItem();
        resetzoombutton = new javax.swing.JMenuItem();

        setTitle("Expression plot");
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                exitForm(evt);
            }
        });

        graphpanel.setLayout(new javax.swing.BoxLayout(graphpanel, javax.swing.BoxLayout.X_AXIS));

        graphpanel.setPreferredSize(new java.awt.Dimension(600, 300));
        graphpanel.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                graphpanelMouseDragged(evt);
            }
        });
        graphpanel.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                graphpanelMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                graphpanelMouseReleased(evt);
            }
        });

        getContentPane().add(graphpanel, java.awt.BorderLayout.CENTER);

        xscrollbar.setOrientation(javax.swing.JScrollBar.HORIZONTAL);
        xscrollbar.addAdjustmentListener(new java.awt.event.AdjustmentListener() {
            public void adjustmentValueChanged(java.awt.event.AdjustmentEvent evt) {
                xscrollbarAdjustmentValueChanged(evt);
            }
        });

        getContentPane().add(xscrollbar, java.awt.BorderLayout.SOUTH);

        yscrollbar.addAdjustmentListener(new java.awt.event.AdjustmentListener() {
            public void adjustmentValueChanged(java.awt.event.AdjustmentEvent evt) {
                yscrollbarAdjustmentValueChanged(evt);
            }
        });

        getContentPane().add(yscrollbar, java.awt.BorderLayout.EAST);

        optionsmenu.setText("Options");
        relexpcheckbox.setSelected(true);
        relexpcheckbox.setText("Show relative expression levels");
        relexpcheckbox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                relexpcheckboxActionPerformed(evt);
            }
        });

        optionsmenu.add(relexpcheckbox);

        foldchangecheckbox.setText("Use foldchange");
        foldchangecheckbox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                foldchangecheckboxActionPerformed(evt);
            }
        });

        optionsmenu.add(foldchangecheckbox);

        avgfoldchangecheckbox.setText("Average foldchanges");
        avgfoldchangecheckbox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                avgfoldchangecheckboxActionPerformed(evt);
            }
        });

        optionsmenu.add(avgfoldchangecheckbox);

        shownamescheckbox.setText("Show names");
        shownamescheckbox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                shownamescheckboxActionPerformed(evt);
            }
        });

        optionsmenu.add(shownamescheckbox);

        jMenuBar1.add(optionsmenu);

        windowmenu.setText("Window");
        deselectmenuitem.setText("Deselect all");
        deselectmenuitem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                deselectmenuitemActionPerformed(evt);
            }
        });

        windowmenu.add(deselectmenuitem);

        showselectedwindowmenuitem.setText("Show selected");
        showselectedwindowmenuitem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                showselectedwindowmenuitemActionPerformed(evt);
            }
        });

        windowmenu.add(showselectedwindowmenuitem);

        resetzoombutton.setText("Un-Zoom");
        resetzoombutton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                resetzoombuttonActionPerformed(evt);
            }
        });

        windowmenu.add(resetzoombutton);

        jMenuBar1.add(windowmenu);

        setJMenuBar(jMenuBar1);

        pack();
    }//GEN-END:initComponents
    
    private void deselectmenuitemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_deselectmenuitemActionPerformed
        // de-select all sequences
        for(int i=draw1.selecteds.length;--i>=0;){
            draw1.selecteds[i]=0;
        }//end for i
        repaint();
    }//GEN-LAST:event_deselectmenuitemActionPerformed
    
    private void resetzoombuttonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_resetzoombuttonActionPerformed
        // reset the zoom factor to 1
        xscrollbar.setValue(0);
        yscrollbar.setValue(0);
        dozoom=false;
        draw1.xzoom=1;
        draw1.yzoom=1;
        repaint();
    }//GEN-LAST:event_resetzoombuttonActionPerformed
    
    private void shownamescheckboxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_shownamescheckboxActionPerformed
        repaint();
    }//GEN-LAST:event_shownamescheckboxActionPerformed
    
    private void avgfoldchangecheckboxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_avgfoldchangecheckboxActionPerformed
        makedata();
        draw1.init();
        repaint();
    }//GEN-LAST:event_avgfoldchangecheckboxActionPerformed
    
    private void foldchangecheckboxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_foldchangecheckboxActionPerformed
        makedata();
        draw1.init();
        repaint();
    }//GEN-LAST:event_foldchangecheckboxActionPerformed
    
    private void showselectedwindowmenuitemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_showselectedwindowmenuitemActionPerformed
        // open a window allowing selection/deselection of elements
        if(myselectwindow!=null){
            myselectwindow.setVisible(false);
            myselectwindow.dispose();
        }
        myselectwindow=new affyselectwindow(this);
        myselectwindow.setVisible(true);
    }//GEN-LAST:event_showselectedwindowmenuitemActionPerformed
    
    private void xscrollbarAdjustmentValueChanged(java.awt.event.AdjustmentEvent evt) {//GEN-FIRST:event_xscrollbarAdjustmentValueChanged
        repaint();
    }//GEN-LAST:event_xscrollbarAdjustmentValueChanged
    
    private void yscrollbarAdjustmentValueChanged(java.awt.event.AdjustmentEvent evt) {//GEN-FIRST:event_yscrollbarAdjustmentValueChanged
        repaint();
    }//GEN-LAST:event_yscrollbarAdjustmentValueChanged
    
    private void graphpanelMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_graphpanelMouseDragged
        mousex=evt.getX()+xscrollbar.getValue();
        mousey=evt.getY()+yscrollbar.getValue();
        repaint();
    }//GEN-LAST:event_graphpanelMouseDragged
    
    private void graphpanelMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_graphpanelMouseReleased
        mousex=evt.getX()+xscrollbar.getValue();
        mousey=evt.getY()+yscrollbar.getValue();
        if(dozoom){
            draw1.zoom(mousestartx,mousestarty,mousex,mousey);
            dozoom=false;
        }
        if(doselect){
            draw1.select(mousestartx,mousestarty,mousex,mousey);
            doselect=false;
        }
        mousex=0;
        mousey=0;
        mousestartx=0;
        mousestarty=0;
        repaint();
    }//GEN-LAST:event_graphpanelMouseReleased
    
    private void graphpanelMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_graphpanelMousePressed
        mousex=evt.getX()+xscrollbar.getValue();
        mousey=evt.getY()+yscrollbar.getValue();
        mousestartx=mousex;
        mousestarty=mousey;
        if(evt.isAltDown() || evt.isAltGraphDown()){
            dozoom=true;
            if (evt.getButton() == MouseEvent.BUTTON3) {
                //alt & right click=unzoom everything
                draw1.xzoom=1;
                draw1.yzoom=1;
                xscrollbar.setValue(0);
                yscrollbar.setValue(0);
                dozoom=false;
            }
        }else if(evt.isControlDown()){
            doselect=true;
        }else{
            doselect=false;
            dozoom=false;
        }
        repaint();
    }//GEN-LAST:event_graphpanelMousePressed
    
    private void relexpcheckboxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_relexpcheckboxActionPerformed
        repaint();
    }//GEN-LAST:event_relexpcheckboxActionPerformed
    
    /** Exit the Application */
    private void exitForm(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_exitForm
        this.setVisible(false);
        this.dispose();
    }//GEN-LAST:event_exitForm
    
    /**
     * @param args the command line arguments
     */
    
    drawpanel draw1=new drawpanel();
    ArrayList<datapoint[]> datlist=null;
    int mousex=0;
    int mousey=0;
    int mousestartx=0;
    int mousestarty=0;
    boolean dozoom=false;
    boolean doselect=false;
    affyselectwindow myselectwindow=null;
    Vector<replicates> datavec=null;
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JCheckBoxMenuItem avgfoldchangecheckbox;
    private javax.swing.JMenuItem deselectmenuitem;
    private javax.swing.JCheckBoxMenuItem foldchangecheckbox;
    private javax.swing.JPanel graphpanel;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JMenu optionsmenu;
    private javax.swing.JCheckBoxMenuItem relexpcheckbox;
    private javax.swing.JMenuItem resetzoombutton;
    private javax.swing.JCheckBoxMenuItem shownamescheckbox;
    private javax.swing.JMenuItem showselectedwindowmenuitem;
    private javax.swing.JMenu windowmenu;
    private javax.swing.JScrollBar xscrollbar;
    private javax.swing.JScrollBar yscrollbar;
    // End of variables declaration//GEN-END:variables
    
    void makedata(){
        // change the data I use to foldchange data or back again
        //watch out never to change the values in the datapoint.values or datapoint.wtvalues arrays
        if(foldchangecheckbox.isSelected()){
            //calculate the data as foldchanges
            if(avgfoldchangecheckbox.isSelected()){
                //works!
                int valint;
                //the amount of data doesn't change
                datapoint[] tmparr;
                int arrsize;
                float tmpval;
                for(int i=datlist.size();--i>=0;){
                    tmparr=(datapoint[])datlist.get(i);
                    arrsize=tmparr.length;
                    for(int j=0;j<arrsize;j++){
                        if(tmparr[j]!=null){
                            valint = tmparr[j].values.length;
                            tmparr[j].value=0;
                            for(int k=valint;--k>=0;){
                                tmparr[j].value+=tmparr[j].values[k];
                            }//end for k
                            tmparr[j].value/=valint;
                            
                            valint = tmparr[j].wtvalues.length;
                            tmparr[j].wtval=0;
                            for(int k=valint;--k>=0;){
                                tmparr[j].wtval+=tmparr[j].wtvalues[k];
                            }//end for k
                            tmparr[j].wtval/=valint;
                            
                            //now save foldchange to tmparr[j].value
                            tmparr[j].value/=tmparr[j].wtval;
                            tmparr[j].stdev=0;
                            for(int k=0;k<valint;k++){
                                tmpval=(tmparr[j].values[k]/tmparr[j].wtval)-tmparr[j].value;
                                tmparr[j].stdev+=tmpval*tmpval;
                            }
                            if(valint>1){
                                tmparr[j].stdev=(float)java.lang.Math.sqrt((1/(valint-1))*tmparr[j].stdev);
                            }else{
                                tmparr[j].stdev=0;
                            }
                        }
                    }//end for j
                }//end for i
            }else{//if avgfoldchangecheckbox !=selected
                //doesn't work yet
                int valint,wtint;
                float[] newarr;
                float avgval=0,tmpval=0;
                datapoint[] tmparr;
                int arrsize;
                //the datanum increases as I do all vs. all comparisons of the possible foldchanges
                for(int i=datlist.size();--i>=0;){
                    tmparr=(datapoint[])datlist.get(i);
                    arrsize=tmparr.length;
                    for(int j=arrsize;--j>=0;){
                        if(tmparr[j]!=null){
                            valint = tmparr[j].values.length;
                            wtint = tmparr[j].wtvalues.length;
                            newarr=new float[valint*wtint];//array contains all vs. all foldchanges
                            avgval=0;
                            for(int k=valint;--k>=0;){
                                for(int l=wtint;--l>=0;){
                                    newarr[k*wtint+l]=tmparr[j].values[k]/tmparr[j].wtvalues[l];
                                    avgval+=newarr[k*wtint+l];
                                }//end for l
                            }//end for k
                            tmparr[j].value=avgval/(valint*wtint);
                            tmparr[j].stdev=0;
                            for(int k=0;k<valint;k++){
                                for(int l=0;l<wtint;l++){
                                    tmpval=newarr[k*wtint+l]-tmparr[j].value;
                                    tmparr[j].stdev+=tmpval*tmpval;
                                }//end for l
                            }//end for k
                            if(valint>1){
                                tmparr[j].stdev=(float)java.lang.Math.sqrt((1/(valint-1))*tmparr[j].stdev);
                            }else{
                                tmparr[j].stdev=0;
                            }
                        }
                    }//end for j
                }//end for i
            }
        }else{
            //calculate the actual data
            int valint;
            //the amount of data doesn't change
            datapoint[] tmparr;
            int arrsize;
            float tmpval;
            for(int i=datlist.size();--i>=0;){
                tmparr=(datapoint[])datlist.get(i);
                arrsize=tmparr.length;
                for(int j=0;j<arrsize;j++){
                    if(tmparr[j]!=null){
                        valint = tmparr[j].values.length;
                        tmparr[j].value=0;
                        for(int k=0;k<valint;k++){
                            tmparr[j].value+=tmparr[j].values[k];
                        }//end for k
                        
                        tmparr[j].value/=valint;
                        tmparr[j].stdev=0;
                        for(int k=0;k<valint;k++){
                            tmpval=tmparr[j].values[k]-tmparr[j].value;
                            tmparr[j].stdev+=tmpval*tmpval;
                        }
                        
                        if(valint>1){
                            tmparr[j].stdev=(float)java.lang.Math.sqrt((1/(valint-1))*tmparr[j].stdev);
                        }else{
                            tmparr[j].stdev=0;
                        }
                    }
                }//end for j
            }//end for i
        }
    }//end makedata
    
    
    class drawpanel extends javax.swing.JPanel{
        
        /**
         * 
         */
        private static final long serialVersionUID = -6995289276294816339L;
        
        public void init(){
            //initialize the data for this graph
            if(datlist==null){
                return;
            }
            datnum=datlist.size();
            //System.out.println("datnum (selected sequences)="+datnum);
            maxmin=new float[datnum][2];
            drawdat=new int[datnum];
            selecteds=new int[datnum];
            float max=-1;
            float min=-1;
            maxmax=-1;
            minmin=-1;
            colorarr=new java.awt.Color[datnum];
            if(datnum>0){
                conditions = datlist.get(0).length; // -1;
            }
            avgarr=new float[datnum];
            for(int i=datnum;--i>=0;){
                drawdat[i]=1;
                selecteds[i]=0;
                tmparr=(datapoint[])datlist.get(i);
                max=-1;
                min=-1;
                avgarr[i]=0;
                for(int j=conditions;--j>=0;){
                    if(max<tmparr[j].value || max==-1){
                        max=tmparr[j].value;
                    }
                    if(min>tmparr[j].value || min==-1){
                        min=tmparr[j].value;
                    }
                    avgarr[i]+=tmparr[j].value;
                }//end for j
                avgarr[i]/=conditions;
                maxmin[i][0]=max;
                maxmin[i][1]=min;
                if(maxmax<max || maxmax==-1){
                    maxmax=max;
                }
                if(minmin>min || minmin==-1){
                    minmin=min;
                }
                //now add a new color to the color array
                colorarr[i]=new java.awt.Color(0,((float)i)/datnum,1-((float)i)/datnum);
            }//end for i
        }//end init
        
        int datnum=0;
        int conditions=0;
        int[] drawdat=null;//do I want to draw/hide certain elements?
        int[] selecteds=null;//the currently selected elements
        float[][] maxmin=null;
        float maxmax=-1,minmin=-1;
        datapoint[] tmparr;
        java.awt.Color[] colorarr=null;
        int xoffset=20;
        int yoffset=20;
        float spacer=100;
        int drawwidth,drawheight;
        float xzoom=1;
        float yzoom=1;
        int xval,yval;
        float globalrelstdev=0;
        float[] avgarr=new float[0];
        
        public void paintComponent(java.awt.Graphics g){
            drawwidth=graphpanel.getWidth();
            drawheight=graphpanel.getHeight();
            xval=xscrollbar.getValue();
            yval=yscrollbar.getValue();
            g.setColor(java.awt.Color.white);
            g.fillRect(0,0,drawwidth,drawheight);
            g.setColor(java.awt.Color.black);
            g.drawLine(xoffset,drawheight-yoffset,drawwidth-xoffset,drawheight-yoffset);
            g.drawLine(xoffset,drawheight-yoffset,xoffset,yoffset);
            if(relexpcheckbox.isSelected()){
                g.drawString(String.valueOf(maxmax),xoffset,yoffset);
                g.drawString(String.valueOf(minmin),xoffset,drawheight-yoffset);
            }
            spacer=((drawwidth-xoffset-xoffset)/(float)conditions);
            for(int i=0;i<datnum;i++){
                if(drawdat[i]==1){
                    tmparr=(datapoint[]) datlist.get(i);
                    g.setColor(colorarr[i]);
                    if(relexpcheckbox.isSelected()){
                        //draw the expression values in comparable scale
                        for(int j=1;j<conditions;j++){
                            g.drawLine((int)(xoffset+((j-1)*spacer)*xzoom)-xval,yoffset+(int)((drawheight-yoffset-yoffset)*(1-((tmparr[j-1].value-minmin)/(maxmax-minmin)))*yzoom)-yval,(int)(xoffset+(j*spacer)*xzoom)-xval,yoffset+(int)((drawheight-yoffset-yoffset)*(1-((tmparr[j].value-minmin)/(maxmax-minmin)))*yzoom)-yval);
                        }//end for j
                        for(int j=0;j<conditions;j++){
                            g.drawLine((int)(xoffset+(j*spacer)*xzoom)-xval,yoffset+(int)((drawheight-yoffset-yoffset)*(1-((tmparr[j].value-tmparr[j].stdev-minmin)/(maxmax-minmin)))*yzoom)-yval,(int)(xoffset+(j*spacer)*xzoom)-xval,yoffset+(int)((drawheight-yoffset-yoffset)*(1-((tmparr[j].value+tmparr[j].stdev-minmin)/(maxmax-minmin)))*yzoom)-yval);
                        }//end for j
                    }else{
                        //rescale the expression values to fit between 0 and 1
                        for(int j=1;j<conditions;j++){
                            g.drawLine((int)(xoffset+((j-1)*spacer)*xzoom)-xval,yoffset+(int)((drawheight-yoffset-yoffset)*(1-((tmparr[j-1].value-maxmin[i][1])/(maxmin[i][0]-maxmin[i][1])))*yzoom)-yval,(int)(xoffset+(j*spacer)*xzoom)-xval,yoffset+(int)((drawheight-yoffset-yoffset)*(1-((tmparr[j].value-maxmin[i][1])/(maxmin[i][0]-maxmin[i][1])))*yzoom)-yval);
                        }//end for j
                        for(int j=0;j<conditions;j++){
                            g.drawLine((int)(xoffset+(j*spacer)*xzoom)-xval,yoffset+(int)((drawheight-yoffset-yoffset)*(1-((tmparr[j].value-tmparr[j].stdev-maxmin[i][1])/(maxmin[i][0]-maxmin[i][1])))*yzoom)-yval,(int)(xoffset+(j*spacer)*xzoom)-xval,yoffset+(int)((drawheight-yoffset-yoffset)*(1-((tmparr[j].value+tmparr[j].stdev-maxmin[i][1])/(maxmin[i][0]-maxmin[i][1])))*yzoom)-yval);
                        }//end for j
                    }
                    if(shownamescheckbox.isSelected()){
                        //print the sequences name at the end of the graph
                        if(relexpcheckbox.isSelected()){
                            g.drawString(((datapoint[])datlist.get(i))[0].name,(int)(xoffset+((conditions-1)*spacer)*xzoom),yoffset+(int)((drawheight-yoffset-yoffset)*(1-((tmparr[conditions-1].value-minmin)/(maxmax-minmin)))*yzoom)-yval);
                        }else{
                            //System.out.println("is NOT selected");
                            //g.drawString("*"+((datapoint[])datlist.get(i))[0].name,(int)(xoffset+((conditions-1)*spacer)*xzoom),(int)((drawheight-yoffset)*(1-((tmparr[conditions-1].value-maxmin[(conditions-1)][1])/(maxmin[(conditions-1)][0]-maxmin[(conditions-1)][1])))*yzoom)-yval);
                            g.drawString("*"+((datapoint[])datlist.get(i))[0].name,(int)(xoffset+((conditions-1)*spacer)*xzoom),yoffset+(int)((drawheight-yoffset-yoffset)*(1-((tmparr[conditions-1].value-maxmin[i][1])/(maxmin[i][0]-maxmin[i][1])))*yzoom)-yval);
                        }
                    }
                }
                //now draw the condition abbreviations strings
                g.setColor(java.awt.Color.black);
                for(int j=0;j<conditions;j++){
                    if(((replicates)datavec.get(j)).abbreviation!=null){
                        g.drawString(((replicates)datavec.get(j)).abbreviation,(int)(xoffset+(j*spacer)*xzoom)-xval,drawheight);
                    }
                }//end for i
            }//end for i
            //now draw the currently selected
            g.setColor(java.awt.Color.red);
            for(int i=0;i<datnum;i++){
                if(selecteds[i]==1){
                    tmparr=(datapoint[]) datlist.get(i);
                    if(relexpcheckbox.isSelected()){
                        //draw the expression values in comparable scale
                        for(int j=1;j<conditions;j++){
                            g.drawLine((int)(xoffset+((j-1)*spacer)*xzoom)-xval,yoffset+(int)((drawheight-yoffset-yoffset)*(1-((tmparr[j-1].value-minmin)/(maxmax-minmin)))*yzoom)-yval,(int)(xoffset+(j*spacer)*xzoom)-xval,yoffset+(int)((drawheight-yoffset-yoffset)*(1-((tmparr[j].value-minmin)/(maxmax-minmin)))*yzoom)-yval);
                        }//end for j
                        //and the standard deviation for each value
                        for(int j=0;j<conditions;j++){
                            g.drawLine((int)(xoffset+(j*spacer)*xzoom)-xval,yoffset+(int)((drawheight-yoffset-yoffset)*(1-((tmparr[j].value-tmparr[j].stdev-minmin)/(maxmax-minmin)))*yzoom)-yval,(int)(xoffset+(j*spacer)*xzoom)-xval,yoffset+(int)((drawheight-yoffset-yoffset)*(1-((tmparr[j].value+tmparr[j].stdev-minmin)/(maxmax-minmin)))*yzoom)-yval);
                        }//end for j
                        //and add the background noise level showing which values are within 1 stdev of average
                        //g.drawLine(xoffset,yoffset+(int)((drawheight-yoffset-yoffset)*(1-(((1+globalrelstdev)*avgarr[i]-minmin)/(maxmax-minmin)))*yzoom)-yval,drawwidth-xoffset,yoffset+(int)((drawheight-yoffset-yoffset)*(1-(((1+globalrelstdev)*avgarr[i]-minmin)/(maxmax-minmin)))*yzoom)-yval);
                        //g.drawLine(xoffset,yoffset+(int)((drawheight-yoffset-yoffset)*(1-(((1-globalrelstdev)*avgarr[i]-minmin)/(maxmax-minmin)))*yzoom)-yval,drawwidth-xoffset,yoffset+(int)((drawheight-yoffset-yoffset)*(1-(((1-globalrelstdev)*avgarr[i]-minmin)/(maxmax-minmin)))*yzoom)-yval);
                    }else{
                        //rescale the expression values to fit between 0 and 1
                        for(int j=1;j<conditions;j++){
                            g.drawLine((int)(xoffset+((j-1)*spacer)*xzoom)-xval,yoffset+(int)((drawheight-yoffset-yoffset)*(1-((tmparr[j-1].value-maxmin[i][1])/(maxmin[i][0]-maxmin[i][1])))*yzoom)-yval,(int)(xoffset+(j*spacer)*xzoom)-xval,yoffset+(int)((drawheight-yoffset-yoffset)*(1-((tmparr[j].value-maxmin[i][1])/(maxmin[i][0]-maxmin[i][1])))*yzoom)-yval);
                        }//end for j
                        //and draw the stdev for each value
                        for(int j=0;j<conditions;j++){
                            g.drawLine((int)(xoffset+(j*spacer)*xzoom)-xval,yoffset+(int)((drawheight-yoffset-yoffset)*(1-((tmparr[j].value-tmparr[j].stdev-maxmin[i][1])/(maxmin[i][0]-maxmin[i][1])))*yzoom)-yval,(int)(xoffset+(j*spacer)*xzoom)-xval,yoffset+(int)((drawheight-yoffset-yoffset)*(1-((tmparr[j].value+tmparr[j].stdev-maxmin[i][1])/(maxmin[i][0]-maxmin[i][1])))*yzoom)-yval);
                        }//end for j
                        //and add the background noise level showing which values are within 1 stdev of average
                        //g.drawLine(xoffset,yoffset+(int)((drawheight-yoffset-yoffset)*(1-(((1+globalrelstdev)*avgarr[i]-maxmin[i][1])/(maxmin[i][0]-maxmin[i][1])))*yzoom)-yval,drawwidth-xoffset,yoffset+(int)((drawheight-yoffset-yoffset)*(1-(((1+globalrelstdev)*avgarr[i]-maxmin[i][1])/(maxmin[i][0]-maxmin[i][1])))*yzoom)-yval);
                        //g.drawLine(xoffset,yoffset+(int)((drawheight-yoffset-yoffset)*(1-(((1-globalrelstdev)*avgarr[i]-maxmin[i][1])/(maxmin[i][0]-maxmin[i][1])))*yzoom)-yval,drawwidth-xoffset,yoffset+(int)((drawheight-yoffset-yoffset)*(1-(((1-globalrelstdev)*avgarr[i]-maxmin[i][1])/(maxmin[i][0]-maxmin[i][1])))*yzoom)-yval);
                    }
                    if(relexpcheckbox.isSelected()){
                        g.drawString(((datapoint[])datlist.get(i))[0].name,(int)(xoffset+((conditions-1)*spacer)*xzoom),yoffset+(int)((drawheight-yoffset-yoffset)*(1-((tmparr[conditions-1].value-minmin)/(maxmax-minmin)))*yzoom)-yval);
                    }else{
                        //System.out.println("is NOT selected");
                        //g.drawString("*"+((datapoint[])datlist.get(i))[0].name,(int)(xoffset+((conditions-1)*spacer)*xzoom),(int)((drawheight-yoffset)*(1-((tmparr[conditions-1].value-maxmin[(conditions-1)][1])/(maxmin[(conditions-1)][0]-maxmin[(conditions-1)][1])))*yzoom)-yval);
                        g.drawString("*"+((datapoint[])datlist.get(i))[0].name,(int)(xoffset+((conditions-1)*spacer)*xzoom),yoffset+(int)((drawheight-yoffset-yoffset)*(1-((tmparr[conditions-1].value-maxmin[i][1])/(maxmin[i][0]-maxmin[i][1])))*yzoom)-yval);
                    }
                }
            }//end for i
            if(dozoom || doselect){
                g.setColor(java.awt.Color.red);
                g.drawLine(mousestartx,mousestarty,mousestartx,mousey);
                g.drawLine(mousestartx,mousestarty,mousex,mousestarty);
                g.drawLine(mousex,mousey,mousex,mousestarty);
                g.drawLine(mousex,mousey,mousestartx,mousey);
            }
        }//end paintComponent
        
        //--------------------
        
        void select(int xs, int ys, int xe, int ye){
            //select all datapoint[] that have a dot in this region
            int tmp;
            if(xs>xe){
                tmp=xe;
                xe=xs;
                xs=tmp;
            }
            if(ys>ye){
                tmp=ye;
                ye=ys;
                ys=tmp;
            }
            //simple; maybe later improve:
            boolean addme;
            datapoint[] tmparr;
            int myx,myy;
            for(int i=0;i<datnum;i++){
                addme=false;
                if(drawdat[i]!=1){
                    //this is currently hidden
                    continue;
                }
                tmparr=(datapoint[])datlist.get(i);
                if(relexpcheckbox.isSelected()){
                    for(int j=conditions;--j>=0;){
                        myx=(int)(xoffset+(j*spacer)*xzoom)-xval;
                        myy=yoffset+(int)((drawheight-yoffset-yoffset)*(1-((tmparr[j].value-minmin)/(maxmax-minmin)))*yzoom)-yval;
                        if(myx<=xe && myx>xs){
                            if(myy<=ye && myy>=ys){
                                addme=true;
                                break;
                            }
                        }
                    }//end for j
                    if(addme){
                        selecteds[i]=1;
                    }else{
                        selecteds[i]=0;
                    }
                }else{
                    for(int j=conditions;--j>=0;){
                        myx=(int)(xoffset+(j*spacer)*xzoom)-xval;
                        myy=(int)((drawheight-yoffset)*(1-((tmparr[j].value-maxmin[i][1])/(maxmin[i][0]-maxmin[i][1])))*yzoom)-yval;
                        if(myx<=xe && myx>xs){
                            if(myy<=ye && myy>=ys){
                                addme=true;
                                break;
                            }
                        }
                    }//end for j
                    if(addme){
                        selecteds[i]=1;
                    }else{
                        selecteds[i]=0;
                    }
                }
            }//end for i
            
            if(myselectwindow!=null){
                //then update the selection in there as well
                ArrayList<Integer> tmplist = new ArrayList<Integer>();
                for(int i=0;i<datnum;i++){
                    if(selecteds[i]==1){
                        tmplist.add(new Integer(i));
                    }
                }//end for i
                int[] selarr=new int[tmplist.size()];
                for(int i=tmplist.size();--i>=0;){
                    selarr[i]=((Integer)tmplist.get(i)).intValue();
                }//end for i
                myselectwindow.jList1.setSelectedIndices(selarr);
                myselectwindow.repaint();
            }
        }//end select
        
        //--------------------
        
        void zoom(int xs,int ys,int xe,int ye){
            //zoom in on this region
            int tmp;
            if(xs>xe){
                tmp=xe;
                xe=xs;
                xs=tmp;
            }
            if(ys>ye){
                tmp=ye;
                ye=ys;
                ys=tmp;
            }
            xzoom*=((float)(drawwidth-xoffset-xoffset))/(xe-xs);
            yzoom*=((float)(drawheight-yoffset-yoffset))/(ye-ys);
            xscrollbar.setMaximum((int)(drawwidth*xzoom-drawwidth));
            yscrollbar.setMaximum((int)(drawheight*yzoom-drawheight));
            xscrollbar.setValue(xs);
            yscrollbar.setValue(ys);
        }//end zoom
        
    }//end class drawpanel
    
    
}//end class
